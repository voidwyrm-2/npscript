when not defined(wasm32):
  import std/[
    strformat,
    os,
    strutils
  ]

  import pkg/Noise

import pkg/nargparse

import
  general,
  pgenv,
  lexer,
  parser,
  state,
  interpreter,
  logging

from builtins import langVersion


template q1(v: varargs[untyped]) =
  stderr.writeLine v
  quit 1

when defined(wasm32):
  proc repl() =
    q1 "The REPL is not supported in wasm32 targets"
else:
  proc repl() =
    if not pgReplHistory.fileExists():
      pgReplHistory.writeFile("")

    var hf: File = nil

    if not open(hf, pgReplHistory, fmReadWriteExisting):
      q1 "Cannot open ", pgReplHistory

    defer:
      hf.close()

    var noise = Noise.init()

    for line in hf.readAll().split("\n"):
      noise.historyAdd(line)

    hf.setFilePos(hf.getFileSize(), fspSet)
    
    echo "Page ", langVersion, " REPL; type 'quit' to exit"
  
    let
      basePrompt = "PG > "
      i = newInterpreter()
  
    noise.setPrompt(basePrompt)
  
    while true:
      let stackLen = i.state().stack().len()

      if stackLen > 0:
        noise.setPrompt(fmt"PG <{stackLen}> ")
      else:
        noise.setPrompt(basePrompt)
  
      let ok = noise.readLine()

      if not ok:
        break
  
      let line = noise.getLine()
  
      try:
        let
          l = newLexer("repl", line)
          p = newParser(l.lex())

        i.exec(p.parse())
      except PgQuitError as e:
        quit e.code
      except PgError as e:
        echo e
  
      hf.writeLine(line)
      noise.historyAdd(line)

proc main(args: seq[string]) =
  let argp = newArgparser("page")

  let fHelp = argp.flag(["h", "help"], help="Prints the help message.")
  let fVersion = argp.flag(["v", "version"], help="Prints the language version and exits.")
  let fRepl = argp.flag(["repl"], help="Runs the Page REPL.")
  let fExec = argp.opt(["e", "exec"], help="Executes the given Page snippet.")
  let fTokens = argp.flag(["t", "tokens"], help="Prints the tokens generated by the lexer.")
  let fNodes = argp.flag(["n", "nodes"], help="Prints the nodes generated by the parser.")
  let fLogLevel = argp.opt(["log"], help="Sets the log level; debug messages are NOT guaranteed to be the same between versions.")
  let fForceStd = argp.flag(["fstd", "force-std"], help="Force the standard library to be written; this is normally skipped after the first time Page is run.")

  var leftover: seq[string]
  try:
    leftover = argp.parse(args)
  except ArgparseError as e:
    echo e.msg
    q1 argp

  if fLogLevel.exists:
    try:
      let ll = parseUInt(fLogLevel.value)
      if ll > 255:
        raise newException(ValueError, "")

      startGlobalLogger(stdout, uint8(ll))
      logger.log(fmt"Started global logger with level {logger.level}")
    except ValueError:
      q1 fmt"'{fLogLevel.value}' is not a valid log level"
  else:
    startGlobalLogger(stdout, 0)

  if fHelp.exists:
    echo argp
    return

  if fVersion.exists:
    echo "Page interpreter version ", langVersion
    return

  verifyPg()

  writeStdlib(fForceStd.exists)

  if fExec.exists:
    var tokens: seq[Token]
    let l = newLexer("exec", fExec.value)
    try:
      tokens = l.lex()
    except PgError as e:
      q1 e

    var nodes: seq[Node]
    let p = newParser(tokens)
    try:
      nodes = p.parse()
    except PgError as e:
      q1 e

    let i = newInterpreter()
    try:
      i.exec(nodes)
    except PgQuitError as e:
      quit e.code
    except PgError as e:
      q1 e

    return

  if fRepl.exists:
    repl()
    return

  if leftover.len() == 0:
    q1 "No input files"

  var tokens: seq[Token]

  for arg in leftover:
    var l = newLexer(arg, readFile(arg))
    
    try:
      tokens.add(l.lex())
    except PgError as e:
      q1 e

  if fTokens.exists:
    for t in tokens:
      echo t

  var
    p = newParser(tokens)
    nodes: seq[Node]

  try:
    nodes = p.parse()
  except PgError as e:
    q1 e

  if fNodes.exists:
    for n in nodes:
      echo n

  let i = newInterpreter()
  try:
    i.exec(nodes)
  except PgQuitError as e:
    quit e.code
  except PgError as e:
    q1 e

proc flagHandler(args: seq[string]) =
  try:
    main(args)
  except IOError as e:
    q1 e.msg

when defined(wasm32):
  proc wasmMain(argc: cint, argv: ptr cstring): cint {.exportc: "main".} =
    var args = newSeq[string](int(argc) - 1)

    for i in 1..<argc:
      let item = cast[ptr cstring](cast[uint](argv) + uint(i) * uint(sizeof(pointer)))[]
      if item != nil:
        args[i - 1] = $item

    flagHandler(args)
else:
  when isMainModule:
      flagHandler(commandLineParams())
