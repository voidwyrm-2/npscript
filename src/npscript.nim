import
  std/parseopt,
  std/strformat,
  std/strutils

import
  pkg/noise

import 
  general,
  lexer,
  parser,
  state,
  interpreter

from builtins import langVersion

proc repl() =
  var noise = Noise.init()
  
  echo "NPScript REPL; type '\\exit' to exit"

  var
    i = newInterpreter()
    errored = false

  noise.setPrompt("NPS > ")

  while true:
    let stackLen = i.state().stack().len()
    
    if stackLen > 0:
      noise.setPrompt(fmt"NPS <{stackLen}> ")
    else:
      noise.setPrompt("NPS > ")

    let ok = noise.readLine()


    if not ok:
      break

    let line = noise.getLine()
    if line == "\\exit":
      break

    try:
      var
        l = newLexer("repl", line)
        p = initParser(l.lex())
      i.exec(p.parse())
    except NpsQuitError:
      break
    except NpsError as e:
      echo e
      errored = true

    if line.len() > 0 and (not errored or line.endsWith("\\")):
      noise.historyAdd(if line.endsWith("\\"): line[0..^1] else: line)

    errored = false

var
  optHelp: bool = false
  optVersion: bool = false
  optRepl: bool = false
  optTokens: bool = false
  optNodes: bool = false

template q1(v: untyped) =
  echo v
  quit 1

const usage = """
Usage:
npscript [-h|--help] [-v|--version] [--repl] [-t|--tokens] [-n|--nodes] <files>
  -h|--help     Prints the help message.
  -v|--version  Prints the language version and exits.
  --repl        Runs the NPScript REPL.
  -t|--tokens   Prints the tokens generated by the lexer.
  -n|--nodes    Prints the nodes generated by the parser."""

proc getBoolF(name, val: string): bool =
  case val.toLower()
  of "true", "":
    result = true
  of "false":
    result = false
  else:
    q1 fmt"Unexpected value for '{name}': '{val}'"

proc processArgs(): seq[string] =
  for kind, key, val in getopt():
    case kind
    of cmdLongOption, cmdShortOption:
      case key:
      of "help", "h":
        optHelp = getBoolF(key, val)
      of "version", "v":
        optVersion = getBoolF(key, val)
      of "repl":
        optRepl = getBoolF(key, val)
      of "tokens", "t":
        optTokens = getBoolF(key, val)
      of "nodes", "n":
        optNodes = getBoolF(key, val)
      else:
        q1 fmt"Unknown option '{key}'" & "\n" & usage
    of cmdArgument:
      result.add(key)
    of cmdEnd:
      discard


proc main() =
  let args = processArgs()

  if optHelp:
    echo usage, ""
    return

  if optVersion:
    echo "NPScript interpreter version " & langVersion
    return

  if optRepl:
    repl()
    return

  if args.len() == 0:
    q1 "No input files\n" & usage

  var tokens: seq[Token]

  for arg in args:
    var l = newLexer(arg, readFile(arg))

    try:
      tokens.add(l.lex())
    except NpsError as e:
      q1 e

  if optTokens:
    for t in tokens:
      echo t

  var
    p = initParser(tokens)
    nodes: seq[Node]

  try:
    nodes = p.parse()
  except NpsError as e:
    q1 e

  if optNodes:
    for n in nodes:
      echo n

  var i = newInterpreter()

  try:
    i.exec(nodes)
  except NpsQuitError:
    discard
  except NpsError as e:
    q1 e

when isMainModule:
  main()
