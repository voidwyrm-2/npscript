when not defined(wasm32):
  import std/[
    strformat,
    os,
    strutils
  ]

  import pkg/Noise

import
  argparse,
  general,
  npsenv,
  lexer,
  parser,
  state,
  interpreter,
  logging

from builtins import langVersion


template q1(v: varargs[untyped]) =
  stderr.writeLine v
  quit 1

when defined(wasm32):
  proc repl() =
    q1 "The REPL is not supported in wasm32 targets"
else:
  proc repl() =
    if not npsReplHistory.fileExists():
      npsReplHistory.writeFile("")

    var hf: File = nil

    if not open(hf, npsReplHistory, fmReadWriteExisting):
      q1 "Cannot open ", npsReplHistory

    defer:
      hf.close()

    var noise = Noise.init()

    for line in hf.readAll().split("\n"):
      noise.historyAdd(line)

    hf.setFilePos(hf.getFileSize(), fspSet)
    
    echo "NPScript ", langVersion, " REPL; type 'quit' to exit"
  
    let i = newInterpreter()
  
    noise.setPrompt("NPS > ")
  
    while true:
      let stackLen = i.state().stack().len()
      
      if stackLen > 0:
        noise.setPrompt(fmt"NPS <{stackLen}> ")
      else:
        noise.setPrompt("NPS > ")
  
      let ok = noise.readLine()
  
      if not ok:
        break
  
      let line = noise.getLine()
  
      try:
        let
          l = newLexer("repl", line)
          p = newParser(l.lex())
        i.exec(p.parse())
      except NpsQuitError as e:
        quit e.code
      except NpsError as e:
        echo e
  
      hf.writeLine(line)
      noise.historyAdd(line)

proc main(args: seq[string]) =
  let argp = newArgparser("npscript")
  argp.flag(["h", "help"], help="Prints the help message.")
  argp.flag(["v", "version"], help="Prints the language version and exits.")
  argp.flag(["repl"], help="Runs the NPScript REPL.")
  argp.flag(["t", "tokens"], help="Prints the tokens generated by the lexer.")
  argp.flag(["n", "nodes"], help="Prints the nodes generated by the parser.")
  argp.flag(["fstd", "force-std"], help="Force the standard library to be written; this is normally skipped after the first time NPScript is run.")
  argp.opt(["log"], help="Sets the log level; debug messages are NOT guaranteed to be the same between versions.")

  var res: ParseResult
  try:
    res = argp.parse(args)
  except ArgparseError as e:
    echo e.msg
    q1 argp

  let logLevelF = res.get("log")
  if logLevelF.exists:
    try:
      let ll = parseUInt(logLevelF.value)
      if ll > 255:
        q1 fmt"'{logLevelF.value}' is not a valid log level"

      startGlobalLogger(stdout, uint8(ll))
      logger.log(fmt"Started global logger with level {logger.level}")
    except ValueError:
      q1 fmt"'{logLevelF.value}' is not a valid log level"

  if logger == nil:
    startGlobalLogger(stdout, 0)

  if res.get("h").exists:
    echo argp
    return

  if res.get("v").exists:
    echo "NPScript interpreter version ", langVersion
    return

  verifyNps()

  writeStdlib(res.get("fstd").exists)

  if res.get("repl").exists:
    repl()
    return

  let leftover = res.leftover

  if leftover.len() == 0:
    q1 "No input files"

  var tokens: seq[Token]

  for arg in leftover:
    var l = newLexer(arg, readFile(arg))
    
    try:
      tokens.add(l.lex())
    except NpsError as e:
      q1 e

  if res.get("t").exists:
    for t in tokens:
      echo t

  var
    p = newParser(tokens)
    nodes: seq[Node]

  try:
    nodes = p.parse()
  except NpsError as e:
    q1 e

  if res.get("n").exists:
    for n in nodes:
      echo n


  var i = newInterpreter()

  try:
    i.exec(nodes)
  except NpsQuitError as e:
    quit e.code
  except NpsError as e:
    q1 e

proc flagHandler(args: seq[string]) =
  try:
    main(args)
  except IOError as e:
    q1 e.msg

when defined(wasm32):
  proc wasmMain(argc: cint, argv: ptr cstring): cint {.exportc: "main".} =
    var args = newSeq[string](int(argc) - 1)

    for i in 1..<argc:
      let item = cast[ptr cstring](cast[uint](argv) + uint(i) * uint(sizeof(pointer)))[]
      if item != nil:
        args[i - 1] = $item

    flagHandler(args)
else:
  when isMainModule:
      flagHandler(commandLineParams())
