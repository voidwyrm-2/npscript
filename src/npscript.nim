when not defined(wasm32):
  import std/[
    strformat,
    os
  ]

  import pkg/Noise

import
  argparse,
  general,
  lexer,
  parser,
  state,
  interpreter

from builtins import langVersion


template q1(v: varargs[untyped]) =
  stderr.writeLine v
  quit 1

when defined(wasm32):
  proc repl() =
    q1 "The REPL is not supported in wasm32 targets"
else:
  proc repl() =
    var noise = Noise.init()
    
    echo "NPScript ", langVersion, " REPL; type 'quit' to exit"
  
    var
      i = newInterpreter()
      errored = false
  
    noise.setPrompt("NPS > ")
  
    while true:
      let stackLen = i.state().stack().len()
      
      if stackLen > 0:
        noise.setPrompt(fmt"NPS <{stackLen}> ")
      else:
        noise.setPrompt("NPS > ")
  
      let ok = noise.readLine()
  
      if not ok:
        break
  
      let line = noise.getLine()
  
      try:
        var
          l = newLexer("repl", line)
          p = newParser(l.lex())
        i.exec(p.parse())
      except NpsQuitError as e:
        quit e.code
      except NpsError as e:
        echo e
        errored = true
  
      noise.historyAdd(line)
  
      errored = false

proc main(args: seq[string]) =
  let argp = newArgparser("npscript")
  argp.flag(["h", "help"], help="Prints the help message.")
  argp.flag(["v", "version"], help="Prints the language version and exits.")
  argp.flag(["repl"], help="Runs the NPScript REPL.")
  argp.flag(["t", "tokens"], help="Prints the tokens generated by the lexer.")
  argp.flag(["n", "nodes"], help="Prints the nodes generated by the parser.")

  var res: ParseResult
  try:
    res = argp.parse(args)
  except ArgparseError as e:
    echo e.msg
    q1 argp

  if res.get("h").exists:
    echo argp
    return

  if res.get("v").exists:
    echo "NPScript interpreter version ", langVersion
    return

  if res.get("repl").exists:
    repl()
    return

  let leftover = res.leftover

  if leftover.len() == 0:
    q1 "No input files"

  var tokens: seq[Token]

  for arg in leftover:
    var l = newLexer(arg, readFile(arg))
    
    try:
      tokens.add(l.lex())
    except NpsError as e:
      q1 e

  if res.get("t").exists:
    for t in tokens:
      echo t

  var
    p = newParser(tokens)
    nodes: seq[Node]

  try:
    nodes = p.parse()
  except NpsError as e:
    q1 e

  if res.get("n").exists:
    for n in nodes:
      echo n


  var i = newInterpreter()

  try:
    i.exec(nodes)
  except NpsQuitError as e:
    quit e.code
  except NpsError as e:
    q1 e

proc flagHandler(args: seq[string]) =
  try:
    main(args)
  except IOError as e:
    q1 e.msg

when defined(wasm32):
  proc wasmMain(argc: cint, argv: ptr cstring): cint {.exportc: "main".} =
    var args = newSeq[string](int(argc) - 1)

    for i in 1..<argc:
      let item = cast[ptr cstring](cast[uint](argv) + uint(i) * uint(sizeof(pointer)))[]
      if item != nil:
        args[i - 1] = $item

    flagHandler(args)
else:
  when isMainModule:
      flagHandler(commandLineParams())
